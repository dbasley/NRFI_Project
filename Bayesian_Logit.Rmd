---
title: "Bayesian Logistic Regression"
author: "Devin Basley"
date: "2024-04-22"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)


```

# Data and Data Cleaning

```{r}

# Load Data
statcast_2023_first_inning <- read_csv("statcast_2023_first_inning.csv")


#
statcast_2023_first_inning$on_1b[is.na(statcast_2023_first_inning$on_1b)] <- "woo"
statcast_2023_first_inning$on_2b[is.na(statcast_2023_first_inning$on_2b)] <- "woo"
statcast_2023_first_inning$on_3b[is.na(statcast_2023_first_inning$on_3b)] <- "woo"

#statcast_2023_first_inning <- statcast_2023_first_inning[rev(1:nrow(statcast_2023_first_inning)), ]

# Vector of Events that only include action events
# Balls and Strikes that DO NOT result in walks or strikeouts excluded
included_events <- c("double", "field_out", "force_out",
                     "home_run", "sac_fly", "strikeout", "walk",
                     "double_play", "fielders_choice",
                     "sac_fly_double_play",
                     "strikeout_double_play", "field_error",
                     "fielders_choice_out", "hit_by_pitch", "sac_bunt", "single",
                     "triple")


# Filter statcast data for only action events
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  filter(events %in% included_events) %>%
  mutate(runs_before = away_score + home_score)


# # Summarize half inning totals
half_innings <- statcast_2023_first_inning %>%
  group_by(inning_topbot) %>%
  summarize(outs_inning = sum(outs_when_up),
            runs_inning = sum(post_bat_score),
            runs_start = first(runs_before),
            max_runs = runs_inning + runs_start)




statcast_2023_first_inning <- statcast_2023_first_inning %>%
  inner_join(half_innings, by = "inning_topbot") %>%
  mutate(runs_roi = max_runs - runs_before)


# Start Game State compuation
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  mutate(bases = paste0(
    if_else(on_1b == "woo", 0, 1),
    if_else(on_2b == "woo", 0, 1),
    if_else(on_3b == "woo", 0, 1)))
    

# Compute Pre and Post AB State
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  mutate(state = paste(bases, outs_when_up),
        new_state = case_when(
          inning_topbot != lag(inning_topbot) ~ NA_character_,
           TRUE ~ lag(state)
         ))



# Reverse Data
statcast_2023_first_inning <- statcast_2023_first_inning[rev(1:nrow(statcast_2023_first_inning)), ]


statcast_2023_first_inning$new_state[is.na(statcast_2023_first_inning$new_state)] <- "woo"

statcast_2023_first_inning <- statcast_2023_first_inning %>%
  mutate(new_state = str_replace(new_state, "woo", "3"))


# End of First Inning Summary
end_inning_data <- statcast_2023_first_inning %>%
  dplyr::select(c(game_date, game_pk, player_name, player_name, batter, post_home_score, post_away_score, inning_topbot, away_team, home_team)) %>%
  group_by(game_pk) %>%
  mutate(away_runs = max(post_away_score),
            home_runs = max(post_home_score),
            total_runs = away_runs + home_runs,
            home = home_team,
            away = away_team) %>%
  ungroup() 
  
# Home team indicator variable
end_inning_data <- end_inning_data %>%
  mutate(is_home = ifelse(inning_topbot == "Bot", 1, 0)) 

end_inning_data <- end_inning_data %>%
  mutate(team = if_else(is_home == 1, home, away),
         runs = if_else(is_home == 1, home_runs, away_runs)) 


# Selecting required columns
new_dataset <- end_inning_data %>%
  dplyr::select(game_pk, team, runs, is_home, player_name)

half_inning_summary <- end_inning_data %>%
  group_by(game_pk, is_home) %>%
  summarize(team = first(team),
            runs = if_else(first(is_home) == 1, max(home_runs), max(away_runs)),
            pitcher = first(player_name),
            PA = n_distinct(batter),
            date = first(game_date)) %>%
  ungroup()

team_info <- end_inning_data %>%
  group_by(game_pk) %>%
  summarise(home_team = first(home),
            away_team = first(away)) %>%
  ungroup()



# Merge team information with half_inning_data
half_inning_data <- half_inning_summary %>%
  left_join(team_info, by = "game_pk")

mlb_team_run_rate <- half_inning_summary %>%
  group_by(team) %>%
  summarise(
    run_rate_away = mean(if_else(is_home == 0, runs, NA), na.rm = TRUE),
    run_rate_home = mean(if_else(is_home == 1, runs, NA), na.rm = TRUE)
  ) %>%
  ungroup()


# Home run rate as numeric variable
mlb_team_run_rate$run_rate_home <- as.numeric(mlb_team_run_rate$run_rate_home)
# Away run rate as numeric variable
mlb_team_run_rate$run_rate_away <- as.numeric(mlb_team_run_rate$run_rate_away)


half_inning_data <- half_inning_data %>%
  inner_join(mlb_team_run_rate, by = "team")




inning_summary <- half_inning_data %>%
  group_by(game_pk) %>%
  summarize(
    home_team = first(home_team),
    away_team = first(away_team),
    home_runs = sum(if_else(is_home == 1, runs, 0)),
    away_runs = sum(if_else(is_home == 0, runs, 0)),
    zero_runs = if_else(home_runs + away_runs == 0, "0", "1"),
    home_run_rate = first(run_rate_home),
    away_run_rate = first(run_rate_away),
    home_pitcher = first(pitcher),
    away_pitcher = pitcher,
    home_fip = first(FIP),
    away_fip = FIP,
    date = first(date)
  ) %>%
  ungroup()



inning_summary <- inning_summary %>%
  filter(home_pitcher != away_pitcher)


# # Join half_inning_data with inning_summary by game_pk
# inning_summary <- left_join(half_inning_data, inning_summary, by = "game_pk")




```


```{r}
# Group half_inning_data by game_pk and is_home to calculate FIP for home and away pitchers
pitcher_stats_grouped <- half_inning_data %>%
  group_by(game_pk, is_home) %>%
  summarize(
    home_pitcher_fip = if_else(first(is_home) == 1, first(FIP), NA_real_),
    away_pitcher_fip = if_else(first(is_home) == 0, first(FIP), NA_real_)
  ) %>%
  ungroup()

# Join the calculated FIP for home and away pitchers with inning_summary
final_data <- left_join(inning_summary, pitcher_stats_grouped, by = "game_pk")

# Ensure distinct games in the final_data
final_data <- final_data %>%
  distinct(game_pk, .keep_all = TRUE)

# View the final_data
print(final_data)



```




# Bayesian Poisson Model


```{r}

library(rstanarm)
options(mc.cores = parallel::detectCores())
team_runs_model <- stan_glmer(runs ~ is_home + run_rate_home + FIP + PA + run_rate_away + (1 | home_team) + (1 | away_team) + (1 | pitcher),
                              family = poisson,
                              data = half_inning_data,
                              cores = 8,
                              iter = 2000 * 2,
                              seed = 2015,
                              chains = 4)


```

# Bayesian Poisson Regression Predictions

```{r}


#nrfi_preds <- posterior_predict(team_runs_model, newdata = half_inning_data, seed = 2023)

nrfi_preds_poisson <- posterior_predict(team_runs_model, newdata = select(half_inning_data, c(is_home,
                                                       away_team,
                                                       home_team,
                                                       pitcher,
                                                       run_rate_away,
                                                       run_rate_home,
                                                       FIP,
                                                       PA)), seed = 30)



                                         
par(mfrow=c(1,2))
hist(nrfi_preds_home, main = "CLE Runs vs SEA", 
     xlab = "# of Runs")

hist(nrfi_preds_away, main = "SEA Runs vs CLE", 
     xlab = "# of Runs")



```


# Bayesian Logistic Regression

```{r}

nrfi_model_logit <- stan_glmer(as.factor(zero_runs) ~  home_run_rate + away_run_rate +
                                 home_fip + away_fip + (1 | home_team) + (1 | away_team) + 
                                 (1 | home_pitcher) + (1 | away_pitcher),
                              family = binomial,
                              data = inning_summary,
                              cores = 8,
                              iter = 2000 * 2,
                              seed = 2015,
                              chains = 4)

posterior <- as.matrix(nrfi_model_logit)
plot_title <- ggtitle("Posterior distributions",
                      "with medians and 80% intervals")

mcmc_areas(posterior,
           #pars = c("cyl", "drat", "am", "wt"),
           prob = 0.8) + plot_title

library(bayesplot)

baye

library(lme4)

nrfi_logit <- glmer(as.factor(zero_runs) ~  home_run_rate + away_run_rate +
                                 home_fip + away_fip + (1 | home_team) + (1 | away_team) + 
                                 (1 | home_pitcher) + (1 | away_pitcher),
                              family = binomial,
                              data = inning_summary)

summary(x)

pred_probs <- predict(x, newdata = inning_summary, type = "response")

prediction <- ifelse(pred_probs > 0.5, "NRFI", "YRFI")


inning_summary$pred_outcome <- prediction

accuracy <- mean(prediction == inning_summary$zero_runs) * 100

# Print accuracy
cat("Prediction Accuracy:", accuracy, "%")


nrfi_logit_preds <- posterior_predict(nrfi_model_logit,
                                        newdata = select(inning_summary, c(home_team,
                                                       away_team,
                                                       home_pitcher,
                                                       away_pitcher,
                                                       home_run_rate,
                                                       away_run_rate,
                                                       home_fip,
                                                       away_fip)),
                                      seed = 30
                                      )

nrfi_logit_preds_test <- posterior_predict(nrfi_model_logit,
                                      newdata = tibble(home_team = "SEA",
                                                       away_team = "CLE"),
                                      seed = 20)

cat("Probability of NRFI", mean(sum(nrfi_logit_preds == 0) / length(nrfi_logit_preds) * 100), "%")

cat("Probability of NRFI between SEA (home) and CLE (away)", sum(nrfi_logit_preds_test == 0) / length(nrfi_logit_preds_test) * 100, "%")


nrfi_logit_preds <- tibble(nrfi_logit_preds)

nrfi_logit_preds <- tibble(colMeans(nrfi_logit_preds))


# Add predictions to inning_summary
inning_summary_with_preds <- bind_cols(inning_summary, nrfi_logit_preds)

# Assuming actual outcomes are stored in a column named actual_outcome
# For example, if actual_outcome is binary (0 or 1), representing a win or loss for the home team, respectively
# You can compare it with the predicted probabilities
inning_summary_with_preds <- inning_summary_with_preds %>%
  mutate(predicted_outcome = if_else(colMeans(nrfi_logit_preds) > 0.5, "NRFI", "YRFI"))


# Now you can compare the predicted outcomes with the actual outcomes
comparison <- inning_summary_with_preds %>%
  select(game_pk, predicted_outcome, total_runs)

# Check the comparison
print(comparison)

# Assuming you have comparison data frame as described in the previous response

# Calculate accuracy
accuracy <- mean(comparison$predicted_outcome == comparison$total_runs)

# Print accuracy
print(paste("Accuracy:", accuracy))




```






```{r}



# Join pitcher_stats with half_inning_data by player_name
half_inning_data <- left_join(half_inning_data, pitcher_stats, by = c("pitcher" = "player_name"))

```






# Code for Home and Away Team Runs Rates

```{r}

mlb_team_run_rate <- half_inning_summary %>%
  group_by(team) %>%
  summarise(
    run_rate_away = mean(if_else(is_home == 0, runs, NA), na.rm = TRUE),
    run_rate_home = mean(if_else(is_home == 1, runs, NA), na.rm = TRUE)
  ) %>%
  ungroup()


# Home run rate as numeric variable
mlb_team_run_rate$run_rate_home <- as.numeric(mlb_team_run_rate$run_rate_home)
# Away run rate as numeric variable
mlb_team_run_rate$run_rate_away <- as.numeric(mlb_team_run_rate$run_rate_away)


half_inning_data <- half_inning_data %>%
  inner_join(mlb_team_run_rate, by = "team")

```



# Feature Building 

### FIP
```{r}
# Group data by pitcher and calculate FIP components
pitcher_stats <- statcast_2023_first_inning %>%
  group_by(player_name) %>%
  summarize(
    HR = sum(events == "home_run"),
    BB = sum(events == "walk"),
    HBP = sum(events == "hit_by_pitch"),
    K = sum(events == "strikeout"),
    IP = sum(outs_when_up) / 3
  )

# Define FIP constant
FIP_constant <- 3.2

# Calculate FIP for each pitcher
pitcher_stats <- pitcher_stats %>%
  mutate(FIP = pmax((13 * HR + 3 * (BB + HBP) - 2 * K) / IP + FIP_constant, 0))

pitcher_stats <- pitcher_stats %>%
  dplyr::select(c(player_name, FIP))


# Join pitcher_stats with half_inning_data by player_name
half_inning_data <- left_join(half_inning_data, pitcher_stats, by = c("pitcher" = "player_name"))

# half_inning_data$FIP <- half_inning_data$FIP.y
# 
# half_inning_data <- half_inning_data %>%
#   select(-c(FIP.x, FIP.y, IP, K, HBP, HR, BB))

```

### K/9

```{r}
# Assuming you have a dataframe named statcast_data with columns 'player_name', 'events', and 'outs_when_up'

# Filter the data for strikeouts
strikeouts_data <- statcast_2023_first_inning %>%
  filter(events == "strikeout")

# Group data by pitcher and calculate total strikeouts and innings pitched
pitcher_stats <- strikeouts_data %>%
  group_by(player_name) %>%
  summarize(
    K = n(),  # Total strikeouts
    IP = sum(outs_when_up) / 3  # Total innings pitched
  )

# Compute K/9 for each pitcher
pitcher_stats <- pitcher_stats %>%
  mutate(
    K_per_9 = (K / IP) * 9
  )

# View the calculated K/9 for each pitcher
print(pitcher_stats)



```


### HR Rate

```{r}
# Assuming you have a dataframe named statcast_data with columns 'team_name', 'events', and 'outs_when_up'

# Filter the data for home runs
home_runs_data <- statcast_2023_first_inning %>%
  filter(events == "home_run")

# Group data by team and calculate total home runs and innings pitched
team_stats_home <- home_runs_data %>%
  group_by(home_team) %>%
  summarize(
    HR = n(),  # Total home runs
    IP = sum(outs_when_up)  # Total innings pitched
  )

# Compute HR/9 for each team
team_stats_home <- team_stats_home %>%
  mutate(
    HR_per_9 = (HR / IP) * 9
  )

# Group data by team and calculate total home runs and innings pitched
team_stats_away <- home_runs_data %>%
  group_by(away_team) %>%
  summarize(
    HR = n(),  # Total home runs
    IP = sum(outs_when_up)  # Total innings pitched
  )

# Compute HR/9 for each team
team_stats_away <- team_stats_away %>%
  mutate(
    HR_per_9 = (HR / IP) * 9
  )


# Merge home and away team stats
combined_team_stats <- bind_rows(
  mutate(team_stats_home, team = home_team),
  mutate(team_stats_away, team = away_team)
) %>%
  group_by(team) %>%
  summarise(
    HR = sum(HR),  # Total home runs
    IP = sum(IP)  # Total innings pitched
  ) %>%
  mutate(
    HR_per_9 = (HR / IP) * 9  # Calculate HR/9
  )

# Display combined team stats
print(combined_team_stats)


# View the calculated HR/9 for each team
#print(team_stats)




```



# Runs Against Rate

```{r}

# Calculate total runs scored against each team
total_runs_against <- end_inning_data %>%
  group_by(team) %>%
  summarise(total_runs_against = sum(runs))

# Count total innings played by each team
total_innings_played <- end_inning_data %>%
  group_by(team) %>%
  summarise(total_innings = n_distinct(game_pk))

# Merge total runs against and total innings played data
runs_against_data <- total_runs_against %>%
  left_join(total_innings_played, by = "team")

# Compute runs against rate
runs_against_data <- runs_against_data %>%
  mutate(runs_against_rate = total_runs_against / total_innings)


print(runs_against_data)


```




```{r}

# Load necessary libraries
library(xgboost)

# Assuming your data frame is named inning_summary
# Convert zero_runs to binary (0/1)
inning_summary$zero_runs <- as.integer(inning_summary$zero_runs == "1")

# Specify predictors (X) and response variable (y)
X <- inning_summary[, c("home_run_rate", "away_run_rate", "home_fip", "away_fip", "home_pitcher", "away_pitcher")]


y <- inning_summary$zero_runs

# Convert categorical variables to dummy variables
X <- model.matrix(~ . - 1, data = X)

# Convert data to xgboost DMatrix format
dtrain <- xgb.DMatrix(data = as.matrix(X), label = y)

# Specify model parameters
params <- list(
  objective = "binary:logistic",
  eval_metric = "logloss"
  # Add other parameters as needed
)

# Train xgboost model
xgb_model <- xgboost(params = params, data = dtrain, nrounds = 100)

# Optionally, you can evaluate the model's performance using appropriate metrics
# For example, you can use cross-validation, ROC curve, AUC, etc.

# Make predictions on the training data
pred <- predict(xgb_model, dtrain)

# Convert predicted probabilities to binary predictions
pred_binary <- ifelse(pred > 0.5, 1, 0)

# Assess the model
conf_matrix <- table(Actual = y, Predicted = pred_binary)
accuracy <- sum(diag(conf_matrix)) / sum(conf_matrix)
precision <- conf_matrix[2, 2] / sum(conf_matrix[, 2])
recall <- conf_matrix[2, 2] / sum(conf_matrix[2, ])
f1_score <- 2 * precision * recall / (precision + recall)

# Print evaluation metrics
cat("Confusion Matrix:\n")
print(conf_matrix)
cat("\nAccuracy:", accuracy)
cat("\nPrecision:", precision)
cat("\nRecall:", recall)
cat("\nF1 Score:", f1_score)

library(pROC)
# Plot ROC curve and calculate AUC
roc <- roc(y, pred)
plot(roc, main = "ROC Curve")
auc <- auc(roc)
cat("\nAUC-ROC:", auc)


```