---
title: "NRFi Markov Chain"
author: "Devin Basley"
date: "2024-04-20"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


retro vs statcast:

runs_scored = post_bat_score


base1_run_id = on_1b
base2_run_id = on_2b
base3_run_id = on_3b





```{r}

# Load Data
statcast_2023_first_inning <- read_csv("statcast_2023_first_inning.csv")


#
statcast_2023_first_inning$on_1b[is.na(statcast_2023_first_inning$on_1b)] <- "woo"
statcast_2023_first_inning$on_2b[is.na(statcast_2023_first_inning$on_2b)] <- "woo"
statcast_2023_first_inning$on_3b[is.na(statcast_2023_first_inning$on_3b)] <- "woo"

#statcast_2023_first_inning <- statcast_2023_first_inning[rev(1:nrow(statcast_2023_first_inning)), ]

# Vector of Events that only include action events
# Balls and Strikes that DO NOT result in walks or strikeouts excluded
included_events <- c("double", "field_out", "force_out",
                     "home_run", "sac_fly", "strikeout", "walk",
                     "double_play", "fielders_choice",
                     "sac_fly_double_play",
                     "strikeout_double_play", "field_error",
                     "fielders_choice_out", "hit_by_pitch", "sac_bunt", "single",
                     "triple")


# Filter statcast data for only action events
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  filter(events %in% included_events) %>%
  mutate(runs_before = away_score + home_score)


# Summarize half inning totals
half_innings <- statcast_2023_first_inning %>%
  group_by(inning_topbot) %>%
  summarize(outs_inning = sum(outs_when_up),
            runs_inning = sum(post_bat_score),
            runs_start = first(runs_before),
            max_runs = runs_inning + runs_start)




statcast_2023_first_inning <- statcast_2023_first_inning %>%
  inner_join(half_innings, by = "inning_topbot") %>%
  mutate(runs_roi = max_runs - runs_before)


# Start Game State compuation
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  mutate(bases = paste0(
    if_else(on_1b == "woo", 0, 1),
    if_else(on_2b == "woo", 0, 1),
    if_else(on_3b == "woo", 0, 1)))
    

# statcast_2023_first_inning <- statcast_2023_first_inning %>%
#   mutate(
#     is_runner1 = as.numeric(
#       on_1b == 1 | batter == 1
#     ),
#     is_runner2 = as.numeric(
#       on_1b == 2 | on_2b == 2 | 
#         batter == 2
#     ),
#     is_runner3 = as.numeric(
#       on_1b== 3 | on_2b == 3 |
#         on_3b == 3 | batter == 3
#     ),
#     new_bases = paste0(is_runner1, is_runner2, is_runner3))


# Compute Pre and Post AB State
statcast_2023_first_inning <- statcast_2023_first_inning %>%
  mutate(state = paste(bases, outs_when_up),
        new_state = case_when(
          inning_topbot != lag(inning_topbot) ~ NA_character_,
           TRUE ~ lag(state)
         ))



# Reverse Data
statcast_2023_first_inning <- statcast_2023_first_inning[rev(1:nrow(statcast_2023_first_inning)), ]


# Convert NA Game States to 3 Outs
# woo is place holder for NA
# IDK it wasn't working with NA so I changed it to woo and it worked
# statcast_2023_first_inning$new_state[is.na(statcast_2023_first_inning$new_state)] <- "woo"
# 
# statcast_2023_first_inning <- statcast_2023_first_inning %>%
#   mutate(new_state = str_replace(new_state, "woo", "3"))
# 
# # Table of all game states
# table(statcast_2023_first_inning$new_state)
# 
# 
# # t-matrix of all game states
# t_matrix <- statcast_2023_first_inning %>%
#   select(state, new_state) %>%
#   table()
# 
# dim(t_matrix)
# 
# # p-matrix of game state t-matrix
# p_matrix <- prop.table(t_matrix, 1)
# dim(p_matrix)
# 
# 
# # probablity of 3 outs = 1 in Game State
# p_matrix <- p_matrix %>%
#   rbind("3" = c(rep(0, 24), 1))
# 
# dim(p_matrix)
# 
# 
# p_matrix %>%
#   apply(MARGIN = 1, FUN = sum)
# 
# 
# p_matrix %>%
#   as_tibble(rownames = "state") %>%
#   filter(state == "000 0") %>%
#   pivot_longer(
#     cols = -state, 
#     names_to = "new_state", 
#     values_to = "Prob" 
#   ) %>%
#   filter(Prob > 0)
# 
# 
# num_havent_scored <- function(s) {
#   s |>
#     str_split("") %>%
#     pluck(1) %>%
#     as.numeric() %>%
#     sum(na.rm = TRUE)
# }
# 
# runners_out <- t_matrix %>%
#   row.names() %>%
#   set_names() %>%
#   map_int(num_havent_scored)
#   
# r_runs <- outer(
#   runners_out + 1, 
#   runners_out, 
#   FUN = "-"
# ) %>%
#   cbind("3" = rep(0, 24))
# 
# 
# # Simulate 10,000 half innings
# simulate_half_inning <- function(P, R, start = 1) {
#   s <- start
#   path <- NULL
#   runs <- 0
#   while (s < 25) {
#     s_new <- sample(1:25, size = 1, prob = P[s, ])
#     path <- c(path, s_new)
#     runs <- runs + R[s, s_new]
#     s <- s_new
#   }
#   runs
# }
# 
# set.seed(111653)
# simulated_runs <- 1:10000 %>%
#   map_int(~simulate_half_inning(t_matrix, r_runs))
# 
# 
# table(simulated_runs)
# 
# # Probability of 0 runs across all simulations
# sum(simulated_runs == 0) / 10000
# 






```


# End of First Inning Summary Data for each game
# Model 0 Runs

```{r}
library(tidyverse)


# End of First Inning Summary
end_inning_data <- statcast_2023_first_inning %>%
  select(c(game_date, game_pk, player_name, player_name, batter, post_home_score, post_away_score, inning_topbot, away_team, home_team)) %>%
  group_by(game_pk) %>%
  mutate(away_runs = max(post_away_score),
            home_runs = max(post_home_score),
            total_runs = away_runs + home_runs,
            home = home_team,
            away = away_team) %>%
  ungroup() 
  
# Home team indicator variable
end_inning_data <- end_inning_data %>%
  mutate(is_home = ifelse(inning_topbot == "Bot", 1, 0)) 


end_inning_data <- end_inning_data %>%
  mutate(team = if_else(is_home == 1, home, away),
         runs = if_else(is_home == 1, home_runs, away_runs)) 

# Selecting required columns
new_dataset <- end_inning_data %>%
  select(game_pk, team, runs, is_home, player_name)

half_inning_data <- end_inning_data %>%
  group_by(game_pk, is_home) %>%
  summarise(team = first(team),
            runs = if_else(first(is_home) == 1, max(home_runs), max(away_runs)),
            pitcher = first(player_name),
            PA = n_distinct(batter),
            date = first(game_date)) %>%
  ungroup()

team_info <- end_inning_data %>%
  group_by(game_pk) %>%
  summarise(home_team = first(home),
            away_team = first(away)) %>%
  ungroup()

# Merge team information with half_inning_data
half_inning_data <- half_inning_data %>%
  left_join(team_info, by = "game_pk")


game_summary <- half_inning_data %>%
  group_by(game_pk) %>%
  reframe(
    home_team = first(home_team),
    away_team = first(away_team),
    home_runs = sum(if_else(is_home == 1, runs, 0)),
    away_runs = sum(if_else(is_home == 0, runs, 0)),
    total_runs = if_else(home_runs + away_runs == 0, 1, 0),
    date = first(date)
  ) %>%
  ungroup()





  

# Load required libraries
library(rstanarm)



team_runs_model <- stan_glmer(runs ~ is_home + (1 | home_team) + (1 | away_team),
                              family = poisson,
                              data = half_inning_data,
                              chains = 4, iter = 2500 * 2, 
                              cores = 8,
                              seed = 25)



# Step 4: Model Fitting
# Fit the model
print(team_runs_model, digits = 4)

summary(team_runs_model)


posterior_sample <- as.data.frame(team_runs_model) %>%
  as_tibble()

posterior_sample


par(mfrow = c(3, 1))
hist(posterior_sample$is_home)
hist(posterior_sample$`Sigma[home_team:(Intercept),(Intercept)]`)
hist(posterior_sample$`Sigma[away_team:(Intercept),(Intercept)]`)


prior_summary(object = team_runs_model)


first_inning_preds <- 
  posterior_predict(team_runs_model, 
                    newdata = tibble(away_team = "CLE", 
                                     home_team = "SEA",
                                     is_home = 0,
                                     PA = 4), seed = 25)

hist(first_inning_preds)


                             


# Estimate mean for Poisson distribution
home_prior_mean <- mean(game_summary$home_runs)
away_prior_mean <- mean(game_summary$away_runs)


```



# Poisson simulation function
# Produces NAs
# How to fix

```{r}

# Function to simulate team runs based on a Poisson distribution
sim_team_runs <- function(N_SIMS, shape) {
  
  sim_runs <- rpois(N_SIMS, lambda = shape * 5)
  
  return(sim_runs)
}

set.seed(24)
CLE_sim_runs <- sim_team_runs(300, posterior_sample$`b[(Intercept) home_team:CLE]`)

cat("CLE run simulation:", CLE_sim_runs, "\n")


```



# CV function from HW 4 
# Adjust for scope of Project
# Runs but doesn't work

```{r}
# Set-up number of sims as a global parameter:
N_SIMS <- 1000

# Put it all together:
pred_first_inning_outcomes <- 
  map_dfr(1:nrow(game_summary),
          function(game_i) {
            
            # First gather the match_i data:
            game_i_data <- game_summary[game_i,]
            
            # Next, we'll get the home team parameters, by first checking
            # if it is a team that we observed in the previous data:
            if (game_i_data$home_team %in% game_summary) {
              
              # Get the posterior distribution parameters:
              home_params <- posterior_params[match_i_data$home_team, ]
              
            } else {
              
              # otherwise use the prior distribution parameters:
              home_params <- c(prior_shape, prior_rate)
              
            }
            
            # Repeat for the away team:
            if (game_i_data$away_team %in% eng_2023_results) {
              
              # Get the posterior distribution parameters:
              away_params <- posterior_params[match_i_data$Away, ]
              
            } else {
              
              # otherwise use the prior distribution parameters:
              away_params <- c(prior_shape, prior_rate)
              
            }
            
            # And now use the function from part (a) to generate goal values
            # for home team:
            home_runs <- sim_team_runs(N_SIMS, 
                                         home_params[1],
                                         away_params[2])
            
            # Repeat for away:
            away_runs <- sim_team_runs(N_SIMS, 
                                         away_params[1],
                                         away_params[2])
            
            total_runs = home_runs + away_runs
            
            
            sim_outcomes <- ifelse(total_runs == 0, 1, 0)
                  
            
            # Return a table that has the match id, actual outcome, and predicted probs
            # for each of the outcomes:
            tibble(game_pk = game_i_data$game_pk,
                   total_runs = game_i_data$total_runs,
                   NRFI_win_prob = length(which(sim_outcomes == 1)) / N_SIMS,
                   NRFI_lose_prob = length(which(sim_outcomes == 0)) / N_SIMS)
            
          })

# And display:
pred_first_inning_outcomes


```


```{r}

# Set-up number of sims as a global parameter:
N_SIMS <- 1000

# Put it all together:
pred_first_inning_outcomes <- 
  map_dfr(1:nrow(game_summary),
          function(game_i) {
            
            # First gather the match_i data:
            game_i_data <- game_summary[game_i,]
            
            # Next, we'll get the home team parameters, by first checking
            # if it is a team that we observed in the previous data:
            if (game_i_data$home_team %in% game_summary$home_team) {
              
              # Get the posterior distribution parameters:
              home_params <- posterior_sample$[[game_i_data$home_team, ]]
              
           
              
            } else {
              
              # otherwise use the prior distribution parameters:
              home_params <- home_prior_mean
              
            }
            
        
            
            # Repeat for the away team:
            if (game_i_data$away_team %in% game_summary$away_team) {
              
              # Get the posterior distribution parameters:
              away_params <- posterior_sample$[[game_i_data$away_team, ]]
              
            } else {
              
              # otherwise use the prior distribution parameters:
              away_params <- away_prior_mean
              
            }
            
          
            
            # And now use the function to generate runs for the home team:
            home_runs <- sim_team_runs(N_SIMS, home_params[1], home_params[2])
            
            # Repeat for away:
            away_runs <- sim_team_runs(N_SIMS, away_params[1], away_params[2])
            
            total_runs <- home_runs + away_runs
            
            sim_outcomes <- ifelse(total_runs == 0, 1, 0)
                  
            # Return a table that has the match id, actual outcome, and predicted probabilities
            # for each of the outcomes:
            tibble(game_pk = rep(game_i_data$game_pk, N_SIMS),
                   total_runs = rep(game_i_data$total_runs, N_SIMS),
                   NRFI_win_prob = sum(sim_outcomes == 1) / N_SIMS,
                   NRFI_lose_prob = sum(sim_outcomes == 0) / N_SIMS)
          })


# And display:
pred_first_inning_outcomes

```

